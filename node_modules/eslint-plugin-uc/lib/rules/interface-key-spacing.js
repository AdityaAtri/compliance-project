"use strict";

/**
 * Checks whether a string contains a line terminator as defined in
 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
 * @param {string} str String to test.
 * @returns {boolean} True if str contains a line terminator.
 */
function containsLineTerminator(str) {
  const lineBreakPattern = /\r\n|[\r\n\u2028\u2029]/u;
  return lineBreakPattern.test(str);
}

/**
 * Gets the last element of an array.
 * @param {Array} arr An array.
 * @returns {any} Last element of arr.
 */
function last(arr) {
  return arr[arr.length - 1];
}

function getKey(property) {
  const key = property.key;

  if (property.computed) {
      return sourceCode.getText().slice(key.range[0], key.range[1]);
  }
  return property.key.name;
}



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",

    docs: {
      description: "enforce consistent spacing between keys and types in interface",
      category: "Stylistic Issues"
    },

    fixable: "whitespace"
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Checks whether a property is a member of the property group it follows.
     * @param {ASTNode} lastMember The last Property known to be in the group.
     * @param {ASTNode} candidate The next Property that might be in the group.
     * @returns {boolean} True if the candidate property is part of the group.
     */
    function continuesPropertyGroup(lastMember, candidate) {
      const groupEndLine = lastMember.loc.start.line;
      const candidateStartLine = candidate.loc.start.line;

      if (candidateStartLine - groupEndLine <= 1) {
        return true;
      }

      /*
       * Check that the first comment is adjacent to the end of the group, the
       * last comment is adjacent to the candidate property, and that successive
       * comments are adjacent to each other.
       */
      const leadingComments = sourceCode.getCommentsBefore(candidate);

      if (
        leadingComments.length &&
        leadingComments[0].loc.start.line - groupEndLine <= 1 &&
        candidateStartLine - last(leadingComments).loc.end.line <= 1
      ) {
        for (let i = 1; i < leadingComments.length; i++) {
          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
            return false;
          }
        }
        return true;
      }

      return false;
    }

    /**
     * Starting from the given a node (a property.key node here) looks forward
     * until it finds the last token before a colon punctuator and returns it.
     * @param {ASTNode} node The node to start looking from.
     * @returns {ASTNode} The last token before a colon punctuator.
     */
    function getLastTokenBeforeColon(node) {
      const colonToken = sourceCode.getTokenAfter(node);

      return sourceCode.getTokenBefore(colonToken);
    }

    /**
     * Starting from the given a node (a property.key node here) looks forward
     * until it finds the colon punctuator and returns it.
     * @param {ASTNode} node The node to start looking from.
     * @returns {ASTNode} The colon punctuator.
     */
    function getNextColon(node) {
      return sourceCode.getTokenAfter(node);
    }

    /**
     * Reports an appropriately-formatted error if spacing is incorrect on one
     * side of the colon.
     * @param {ASTNode} property Key-value pair in an object literal.
     * @param {string} side Side being verified - either "key" or "value".
     * @param {string} whitespace Actual whitespace string.
     * @param {int} expected Expected whitespace length.
     * @param {string} mode Value of the mode as "strict" or "minimum"
     * @returns {void}
     */
    // report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
    function report(property, side, whitespace, expected, mode) {
      const diff = whitespace.length - expected;
      const nextColon = getNextColon(property.key);
      const tokenBeforeColon = sourceCode.getTokenBefore(nextColon);
      const tokenAfterColon = sourceCode.getTokenAfter(nextColon);
      const isKeySide = side === "key";
      const locStart = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
      const isExtra = diff > 0;
      const diffAbs = Math.abs(diff);
      const spaces = Array(diffAbs + 1).join(" ");

      if ((
        diff && mode === "strict" ||
        diff < 0 && mode === "minimum" ||
        diff > 0 && !expected && mode === "minimum") &&
        !(expected && containsLineTerminator(whitespace))
      ) {
        let fix;

        if (isExtra) {
          let range;

          // Remove whitespace
          if (isKeySide) {
            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
          } else {
            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
          }
          fix = function (fixer) {
            return fixer.removeRange(range);
          };
        } else {

          // Add whitespace
          if (isKeySide) {
            fix = function (fixer) {
              return fixer.insertTextAfter(tokenBeforeColon, spaces);
            };
          } else {
            fix = function (fixer) {
              return fixer.insertTextBefore(tokenAfterColon, spaces);
            };
          }
        }

        context.report({
          node: property[side === 'key' ? side : 'typeAnnotation'],
          loc: locStart,
          message: "Needs colon alignment",
          data: {
            computed: property.computed ? "computed " : "",
            key: getKey(property)
          },
          fix
        });
      }
    }

    /**
     * Gets the number of characters in a key, including quotes around string
     * keys and braces around computed property keys.
     * @param {ASTNode} property Property of on object literal.
     * @returns {int} Width of the key.
     */
    function getKeyWidth(property) {
      const startToken = sourceCode.getFirstToken(property);
      const endToken = getLastTokenBeforeColon(property.key);
      const tokenAfterEndToken = sourceCode.getTokenAfter(endToken);

      if (tokenAfterEndToken.type === 'Punctuator' && tokenAfterEndToken.value === '?') {
        return tokenAfterEndToken.range[1] - startToken.range[0];
      }

      return endToken.range[1] - startToken.range[0];
    }

    /**
     * Gets the whitespace around the colon in an object literal property.
     * @param {ASTNode} property Property node from an object literal.
     * @returns {Object} Whitespace before and after the property's colon.
     */
    function getPropertyWhitespace(property) {
      const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(
        property.key.range[1], property.typeAnnotation.typeAnnotation.range[0]
      ));
      if (whitespace) {
        return {
          beforeColon: whitespace[1],
          afterColon: whitespace[2]
        };
      }
      return null;
    }

    /**
     * Creates groups of properties.
     * @param  {ASTNode} node ObjectExpression node being evaluated.
     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.
     */
    function createGroups(node) {
      if (node.body.length === 1) {
        return [node.body];
      }

      return node.body.reduce((groups, property) => {
        const currentGroup = last(groups);
        const prev = last(currentGroup);

        if (!prev || continuesPropertyGroup(prev, property)) {
          currentGroup.push(property);
        } else {
          groups.push([property]);
        }

        return groups;
      }, [
        []
      ]);
    }

    /**
     * Verifies correct vertical alignment of a group of properties.
     * @param {ASTNode[]} properties List of Property AST nodes.
     * @returns {void}
     */
    function verifyGroupAlignment(properties) {
      const length = properties.length,
        widths = properties.map(getKeyWidth); // Width of keys, including quotes
      let targetWidth = Math.max(...widths),
        mode = "strict",
        beforeColon = 0,
        afterColon = 1;

      // Conditionally include one space before or after colon
      targetWidth += beforeColon;

      for (let i = 0; i < length; i++) {
        const property = properties[i];
        const whitespace = getPropertyWhitespace(property);

        if (whitespace) { // Object literal getters/setters lack a colon
          const width = widths[i];
          report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
          report(property, "value", whitespace.afterColon, afterColon, mode);
        }
      }
    }

    /**
     * Verifies vertical alignment, taking into account groups of properties.
     * @param  {ASTNode} node ObjectExpression node being evaluated.
     * @returns {void}
     */
    function verifyAlignment(node) {
      createGroups(node).forEach(group => {
        verifyGroupAlignment(group);
      });
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------
    return {
      TSInterfaceDeclaration(node) {
        verifyAlignment(node.body);
      }
    };
  }
};