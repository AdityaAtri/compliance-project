module.exports = {
  meta: {
    fixable: false,
  },
  create(context) {
    return {
      Identifier(node) {
        const name = node.name;
        const is_camel_case = /[a-z]/.test(name.charAt(0)) && !name.includes('_') && !name.includes('-');
        const is_snake_case = name.toLowerCase() === name;
        const is_caps_case = name.toUpperCase() === name;
        const is_pascal_case = /[A-Z]/.test(name.charAt(0)) && !name.includes('_') && !name.includes('-');
        let linted = false;

        // Function name should be camelCase
        if (node.parent
            && node.parent.type === 'AssignmentExpression'
            && node.parent.right
            && (node.parent.right.type === 'FunctionExpression' || node.parent.right.type === 'ArrowFunctionExpression')) {
          if (!is_camel_case) {
            context.report(node, 'Function name should be camelCase');
          }
          return;
        }

        if (node.parent
            && node.parent.type === 'VariableDeclarator'
            && node.parent.init
            && (node.parent.init.type === 'FunctionExpression' || node.parent.init.type === 'ArrowFunctionExpression')) {
          if (!is_camel_case) {
            context.report(node, 'Function name should be camelCase');
          }
          return;
        }

        if (node.parent && node.parent.type === 'FunctionDeclaration' && node.parent.id === node) {
          if (!is_camel_case) {
            context.report(node, 'Function name should be camelCase');
          }
          return;
        }

        // Singletons should be PascalCase.
        if (node.parent
            && node.parent.type === 'VariableDeclarator'
            && node.parent.init
            && node.parent.init.type === 'MemberExpression'
            && node.parent.init.object
            && node.parent.init.object.name === 'Singleton') {
          if (!is_pascal_case) {
            context.report(node, 'Singletons should be PasacalCase');
          }
          return;
        }

       
        // Constant should be CAPS.
        if (node.parent
            && node.parent.type === 'VariableDeclarator'
            && node.parent.init
            && (node.parent.init.type === 'Literal'  || node.parent.init.type === 'ObjectExpression' || node.parent.init.type === 'ArrayExpression' )
            && node.parent.parent
            && node.parent.parent.kind === 'const'
            && (context.getScope().type === 'module' || context.getScope().type === 'global')) {
          if (!is_caps_case) {
            context.report(node, 'Unscoped literal constants should be CAPS');
          }
          return;
        }

        // Module imports via require should be PascalCase
        if (node.parent
            && node.parent.type === 'VariableDeclarator'
            && node.parent.init
            && (context.getScope().type === 'module' || context.getScope().type === 'global')
            && (node.parent.init.type === 'CallExpression' || node.parent.init.type === 'MemberExpression')) {
          let current_node = node.parent.init;
          while (true) {
            if (current_node.type === 'MemberExpression') {
              current_node = current_node.object;
            } else if (current_node.type === 'CallExpression') {
              current_node = current_node.callee;
            } else {
              break;
            }
          }
          if (current_node.name === 'require') {
            if (!is_pascal_case && node.name !== '_') {
              context.report(node, 'Module import name should be PascalCase');
            }
            return;
          }
        }

        // Import should be pascal case.
        // if (node.parent && node.parent.type === 'ImportSpecifier') {
        //   if (!is_pascal_case) {
        //     context.report(node, 'Import should be PascalCase');
        //   }
        //   return;
        // }

        // Object Keys should be snake_case
        // if (node.parent.type === 'MemberExpression' && node.parent.property === node) {
        //   let current_node = node.parent;
        //   while (true) {
        //     if (current_node.type !== 'MemberExpression') {
        //       break;
        //     }
        //     current_node = current_node.parent;
        //   }
        //   if (current_node.type === 'AssignmentExpression') {
        //     if (!is_snake_case) {
        //       context.report(node, 'Object Keys should be snake_case');
        //     }
        //   }
        //   return;
        // }

        // Object keys having function as values should be camelCase.
        if (node.parent.type === 'Property'
            && node.parent.parent
            && node.parent.parent.type === 'ObjectExpression'
            && node.parent.value
            && (node.parent.value.type === 'FunctionExpression' || node.parent.value.type === 'ArrowFunctionExpression')) {
          if (!is_camel_case) {
            context.report(node, 'Object Keys having function as values should be camelCase.');
          }
          return;
        }

        // Function params should be camelCase
        if (node.parent
            && (['FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.parent.type))
            && node.parent.params
            && node.parent.params.includes(node)) {
          if (!is_camel_case) {
            context.report(node, 'Function params should be camelCase');
          }
          return;
        }

        
          if(node.parent.init)
        // Any other variable declaration.
        if (node.parent && node.parent.type === 'VariableDeclarator' && node.parent.id === node && !is_camel_case) {
          context.report(node, 'Variables should be camelCase');
        }

      }
      
    };
  }
};


/*

Variable Name - camelCase
Function Name - camelCase
Function params - camelCase
Object Keys - camelCase
Constants - CAPITAL_CASE
File Name - snake_case
Directory Name - snake_case
Interface - PascalCase
Module - PascalCase
Endpoint - camelCase
Model Name - snake_case
Object Keys - camelCase
Model Field - snake_case

*/ 